# For each microservice, we specify the following:
# • The name of the microservice. This will also be the hostname of the container in the internal Docker network.
# • A build directive that specifies where to find the Dockerfile that was used to build the Docker image.
# A memory limit of 512 MB. 512 MB should be sufficient for all our microservices
# The environment variables that will be set up for the container. In our case, we used these to
# specify which Spring profile to use.

# For the product-composite service, we will also specify port mappings – we will expose its port so it
# can be reached from outside Docker. The other microservices will not be accessible from the outside.

# To avoid microservices trying to connect to databases before they are up and running, the product
# and recommendation services are declared as dependent on the MongoDB database. In depends on, mongodb is the
# name of the service [mongodb].
# This means that Docker Compose will not start up the microservice containers until the database
# containers are launched and reported as healthy by their health checks.

version: '2.1'

services:
  product:
    build: microservices/product-service
    mem_limit: 512m
    environment:
      - SPRING_PROFILES_ACTIVE=docker
    depends_on:
      mongodb:
        condition: service_healthy
      rabbitmq:
        condition: service_healthy

  recommendation:
    build: microservices/recommendation-service
    mem_limit: 512m
    environment:
      - SPRING_PROFILES_ACTIVE=docker
    depends_on:
      mongodb:
        condition: service_healthy
      rabbitmq:
        condition: service_healthy

  review:
    build: microservices/review-service
    mem_limit: 512m
    environment:
      - SPRING_PROFILES_ACTIVE=docker
    depends_on:
      mysql:
        condition: service_healthy
      rabbitmq:
        condition: service_healthy

  # We no longer need the ports as everything will be exposed through the gateway, so we are not exposing eureka to the outside world.
  product-composite:
    build: microservices/product-composite-service
    mem_limit: 512m
    #ports:
    #  - "8081:8080"
    environment:
      - SPRING_PROFILES_ACTIVE=docker
    depends_on:
      rabbitmq:
        condition: service_healthy

  mongodb:
    image: mongo:6.0.4
    mem_limit: 512m
    ports:
      - "27017:27017"
    command: mongod
    healthcheck:
      test: "mongostat -n 1"
      interval: 5s
      timeout: 2s
      retries: 60

  # MySQL, we also declare some environment variables, The root password, The name of the database that will be
  # created on container startup, a username and password for a user that is set up for the database on container startup.
  # We also declare a health check that Docker will run to determine the status of the MongoDB and MySQL databases.
  mysql:
    image: mysql:8.0.32
    mem_limit: 512m
    ports:
      - "3306:3306"
    environment:
      - MYSQL_ROOT_PASSWORD=rootpwd
      - MYSQL_DATABASE=review-db
      - MYSQL_USER=user
      - MYSQL_PASSWORD=pwd
    healthcheck:
      test: "/usr/bin/mysql --user=user --password=pwd --execute \"SHOW DATABASES;\""
      interval: 5s
      timeout: 2s
      retries: 60

  rabbitmq:
    image: rabbitmq:3.11.8-management
    mem_limit: 512m
    ports:
      - 5672:5672
      - 15672:15672
    healthcheck:
      test: [ "CMD", "rabbitmqctl", "status" ]
      interval: 5s
      timeout: 2s
      retries: 60

  eureka:
    build: spring-cloud/eureka
    mem_limit: 512m
    # We no longer need the ports as everything will be exposed through the gateway, so we are not exposing eureka to the outside world.
    #ports:
    #  - "8761:8761"

# Agar hum development (dev) ke liye apni application banayein, toh .jar file ke andar self-signed certificate rakhna chal jaata hai.
# Problem: Ye production ya test environments me secure nahi hai, kyunki self-signed certificate
# trusted CA (Certificate Authority) se sign nahi hota. Browsers aur clients isse trust nahi karte.

# Important point: .jar ko har baar rebuild nahi karna chahiye agar certificate change ho.
# Matlab, aapko runtime pe certificate specify karne ka tareeqa chahiye.
# Jab aap application ko Docker me run karte ho:
  # Docker image me .jar already hoga.
  # Certificate ko Docker image ke andar bake nahi karna chahiye (waise hi .jar me nahi karna chahiye).
  # Iske bajaye Docker volume map karo:
  # Host machine pe certificate rakhte ho.
  # Docker container me volume map karke certificate container ke andar available kara dete ho.

# Update the Docker Compose file, docker-compose.yml, with environment variables for the location, the password
# for the new certificate, and a volume that maps to the folder where the new certificate is placed.
# file:/keystore/edge-test.p12 ka matlab hai certificate container ke /keystore folder me hai.
  gateway:
    environment:
      - SPRING_PROFILES_ACTIVE=docker
      - SERVER_SSL_KEY_STORE=file:/keystore/edge-test.p12
      - SERVER_SSL_KEY_STORE_PASSWORD=testtest
    volumes:
      - $PWD/keystore:/keystore
    build: spring-cloud/gateway
    mem_limit: 512m
    ports:
      - "8443:8443" # To indicate that the edge server talks HTTPS and not HTTP, we also change the port from 8080 to 8443 in the server.port parameter

