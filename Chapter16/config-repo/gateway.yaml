# To indicate that the edge server talks HTTPS and not HTTP, we also change the port from 8080
# to 8443 in the server.port parameter.
server.port: 8443

# It is used to give each microservice a virtual hostname, a name used by the Eureka service to identify each
# microservice. Eureka clients will use this virtual hostname in the URLs that are used to make HTTP
# calls to the microservice.
# The application name property has been moved to the application.yml inside the spring-cloud/gateway.yml
# spring.application.name: gateway

# To prevent eavesdropping on external communication, for example, from the internet, via the public APIs exposed
# by the edge server. We will use HTTPS to encrypt communication. To use HTTPS, we need to do the following:
# • Create a certificate: We will create our own self-signed certificate, sufficient for development purposes.
# • Configure the edge server: It has to be configured to accept only HTTPS-based external traffic using the certificate.
# The certificate file created, edge.p12, is placed in the gateway projects folder, src/main/resources/keystore.
# This means that the certificate file will be placed in the .jar file when it is built and will be available
# on the classpath at runtime at keystore/edge.p12

# The path to the certificate is specified in the server.ssl.key-store parameter, and is set to
# classpath:keystore/edge.p12. This means that the certificate will be picked up on the classpath from the location keystore/edge.p12.
server.ssl:
  key-store-type: PKCS12
  key-store: classpath:keystore/edge.p12
  key-store-password: '{cipher}d59274473b196cebe288f849c442eba34aa497d14a13e10a23f824489e1c23ec'
  key-alias: localhost

spring.cloud.config.uri: http://localhost:8888

#  A route is defined by the following:
# 1. Predicates, which select a route based on information in the incoming HTTP request
# 2. Filters, which can modify both the request and/or the response
# 3. A destination URI, which describes where to send a request
# 4. An ID, that is, the name of the route

# If we, for example, want to route incoming requests where the URL path starts with /product
# composite/ to our product-composite service, we can specify a routing rule like this:

# uri: lb://product-composite: If the route is selected by its predicates, the request will be
# routed to the service that is named product-composite in the discovery service, Netflix Eureka.
# The protocol lb:// is used to direct Spring Cloud Gateway to use the client-side load balancer
# to look up the destination in the discovery service. Now we have removed the eureka and replaced with kubernetes
# service.
spring.cloud.gateway.routes:

  - id: product-composite # The name of the route is product-composite
    uri: http://product-composite # this url is where the request will be forwarded by the gateway
    predicates:
      - Path=/product-composite/**  #  is used to specify what requests this route should match. ** matches zero or more elements in the path.

  # Routes related to the authorization server, these routes are exposed by auth server by default.
  # Routes to the authorization server for the URIs starting with /oauth, /login, and /error have
  # been added in the configuration file, application.yml. These URIs are used to issue tokens
  # for clients, authenticate users, and show error messages.
  - id: oauth2-server
    uri: http://auth-server
    predicates:
      - Path=/oauth2/**

  - id: oauth2-login
    uri: http://auth-server
    predicates:
      - Path=/login/**

  - id: oauth2-error
    uri: http://auth-server
    predicates:
      - Path=/error/**
# To be able to access the API of the config server from outside the microservice landscape, we add a
# routing rule to the edge server. All requests to the edge server that begin with /config will be routed
# to the config server with the following routing rule
  - id: config-server
    uri: ${spring.cloud.config.uri}
    predicates:
      - Path=/config/**
    filters:
      - RewritePath=/config/(?<segment>.*), /$\{segment}

  # for testing purposes:
  # we will try out host-based routing, where Spring Cloud Gateway uses the hostname of the incoming request to determine
  # where to route the request.
  # we can use the Host route predicate to select requests with specific hostnames, and the SetPath filter to set
  # the desired HTTP code in the request path.
  - id: host_route_200
    uri: http://httpstat.us
    predicates:
      - Host=i.feel.lucky:8080
      - Path=/headerrouting/**
    filters:
      - SetPath=/200

  - id: host_route_418
    uri: http://httpstat.us
    predicates:
      - Host=im.a.teapot:8080
      - Path=/headerrouting/**
    filters:
      - SetPath=/418

  - id: host_route_501
    uri: http://httpstat.us
    predicates:
      - Path=/headerrouting/**
    filters:
      - SetPath=/501

# spring.security.oauth2.resourceserver.jwt.issuer-uri ka kaam ye hota hai ke resource server
# (yani yahan gateway) ko batana “kis authorization server ne token issue kiya tha” —
# aur uska public key (JWK set - Json Web Keyset) kahan se milega taake woh JWT verify kar sake.
spring.security.oauth2.resourceserver.jwt.issuer-uri: http://${app.auth-server}:9999

management.endpoint.gateway.enabled: true
management.endpoint.health.show-details: "ALWAYS"
management.endpoints.web.exposure.include: "*"

logging:
  level:
    root: INFO
    org.springframework.cloud.gateway.route.RouteDefinitionRouteLocator: INFO
    org.springframework.cloud.gateway: TRACE

# Configuration for using Micrometer Tracing and Zipkin is added to the configuration file, config-repo/*.yml.
# In the default profile, it is specified that trace information will be sent to Zipkin using the following URL.
management.zipkin.tracing.endpoint: http://zipkin-server:9411/api/v2/spans

# By default, Micrometer Tracing only sends 10% of the traces to Zipkin. To ensure that all traces are
# sent to Zipkin, the following property is added to the default profile
management.tracing.sampling.probability: 1.0

# We also want trace and span IDs to be written to logs; this will enable us to correlate log output from
# cooperating microservices that, for example, fulfill a request sent to the external API.
# We can include the trace and span IDs in the log output by specifying the following log format:
# With the above log format, the log output will look like:
# 2023-04-22T14:02:07.417Z  INFO [product-composite,01234,56789]
# Where product-composite is the name of the microservice, 01234 is the trace ID, and 56789 is the span ID.
logging.pattern.level: "%5p [${spring.application.name:},%X{traceId:-},%X{spanId:-}]"

server.shutdown: graceful
spring.lifecycle.timeout-per-shutdown-phase: 10s


# In the docker-profile which is after --- we are overriding only few properties, the properties that are
# not overridden (defined again) will take the values from above (before ---). Springboot merges both these
# documents and apply profile based overrides.
# Values in a profile override values from the default profile. But other values comes as it is.
# By using YAML files, multiple Spring profiles can be placed in the same file, separated by ---

---

spring.config.activate.on-profile: docker

spring.cloud.config.uri: http://config-server:8888