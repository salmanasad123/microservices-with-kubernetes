# To indicate that the edge server talks HTTPS and not HTTP, we also change the port from 8080
# to 8443 in the server.port parameter.
server.port: 8443

# It is used to give each microservice a virtual hostname, a name used by the Eureka service to identify each
# microservice. Eureka clients will use this virtual hostname in the URLs that are used to make HTTP
# calls to the microservice.
# The application name property has been moved to the application.yml inside the spring-cloud/gateway.yml
# spring.application.name: gateway

# To prevent eavesdropping on external communication, for example, from the internet, via the public APIs exposed
# by the edge server. We will use HTTPS to encrypt communication. To use HTTPS, we need to do the following:
# • Create a certificate: We will create our own self-signed certificate, sufficient for development purposes.
# • Configure the edge server: It has to be configured to accept only HTTPS-based external traffic using the certificate.
# The certificate file created, edge.p12, is placed in the gateway projects folder, src/main/resources/keystore.
# This means that the certificate file will be placed in the .jar file when it is built and will be available
# on the classpath at runtime at keystore/edge.p12

# The path to the certificate is specified in the server.ssl.key-store parameter, and is set to
# classpath:keystore/edge.p12. This means that the certificate will be picked up on the classpath from the location keystore/edge.p12.
server.ssl:
  key-store-type: PKCS12
  key-store: classpath:keystore/edge.p12
  key-store-password: password
  key-alias: localhost

# The ${app.eureka-server} property is resolved by Spring's property mechanism, depending on what Spring profile is activated
app:
  eureka-username: u
  eureka-password: p
  eureka-server: localhost
  auth-server: localhost

spring.cloud.config.uri: http://config-server:8888

# Since Spring Cloud Gateway will use Netflix Eureka to find the microservices it will route traffic to,
# it must be configured as a Eureka client.
eureka:
  client:
    serviceUrl:
      defaultZone: "http://${app.eureka-username}:${app.eureka-password}@${app.eureka-server}:8761/eureka/"
    initialInstanceInfoReplicationIntervalSeconds: 5
    registryFetchIntervalSeconds: 5
  instance:
    leaseRenewalIntervalInSeconds: 5
    leaseExpirationDurationInSeconds: 5

#  A route is defined by the following:
# 1. Predicates, which select a route based on information in the incoming HTTP request
# 2. Filters, which can modify both the request and/or the response
# 3. A destination URI, which describes where to send a request
# 4. An ID, that is, the name of the route

# If we, for example, want to route incoming requests where the URL path starts with /product
# composite/ to our product-composite service, we can specify a routing rule like this:

# uri: lb://product-composite: If the route is selected by its predicates, the request will be
# routed to the service that is named product-composite in the discovery service, Netflix Eureka.
# The protocol lb:// is used to direct Spring Cloud Gateway to use the client-side load balancer
# to look up the destination in the discovery service.
spring.cloud.gateway.routes:

  - id: product-composite # The name of the route is product-composite
    uri: lb://product-composite # this url is where the request will be forwarded by the gateway
    predicates:
      - Path=/product-composite/**  #  is used to specify what requests this route should match. ** matches zero or more elements in the path.

  #  Eureka exposes both an API and a web page for its clients. To provide a clean separation between the
  #  API and the web page in Eureka, we will set up routes as follows:
  #  1. Requests sent to the edge server with the path starting with /eureka/api/ should be handled as a call to the Eureka API.
  #  2. Requests sent to the edge server with the path starting with /eureka/web/ should be handled as a call to the Eureka web page.
  # For example if a request comes to the GATEWAY server like this :
  # http://gateway-server:8080/eureka/api/apps
  # This will match the predicate : Path=/eureka/api/{segment}, and in this case the segment will become /apps
  # Then the request will be re-written using the filters "SetPath" and it will become : /eureka/apps. And then the
  # gateway will forward it to the following url : http://${app.eureka-server}:8761/eureka/apps.

  - id: eureka-api # The name of the route is eureka-api
    uri: http://${app.eureka-server}:8761  # this url is where the request will be forwarded by the gateway
    predicates:
      - Path=/eureka/api/{segment}
    filters:
      - SetPath=/eureka/{segment}

  - id: eureka-web-start
    uri: http://${app.eureka-server}:8761
    predicates:
      - Path=/eureka/web
    filters:
      - SetPath=/

  - id: eureka-web-other
    uri: http://${app.eureka-server}:8761
    predicates:
      - Path=/eureka/**

  # Routes related to the authorization server, these routes are exposed by auth server by default.
  # Routes to the authorization server for the URIs starting with /oauth, /login, and /error have
  # been added in the configuration file, application.yml. These URIs are used to issue tokens
  # for clients, authenticate users, and show error messages.
  - id: oauth2-server
    uri: lb://auth-server
    predicates:
      - Path=/oauth2/**

  - id: oauth2-login
    uri: lb://auth-server
    predicates:
      - Path=/login/**

  - id: oauth2-error
    uri: lb://auth-server
    predicates:
      - Path=/error/**
# To be able to access the API of the config server from outside the microservice landscape, we add a
# routing rule to the edge server. All requests to the edge server that begin with /config will be routed
# to the config server with the following routing rule
  - id: config-server
    uri: ${spring.cloud.config.uri}
    predicates:
      - Path=/config/**
    filters:
      - RewritePath=/config/(?<segment>.*), /$\{segment}

  # for testing purposes:
  # we will try out host-based routing, where Spring Cloud Gateway uses the hostname of the incoming request to determine
  # where to route the request.
  # we can use the Host route predicate to select requests with specific hostnames, and the SetPath filter to set
  # the desired HTTP code in the request path.
  - id: host_route_200
    uri: http://httpstat.us
    predicates:
      - Host=i.feel.lucky:8080
      - Path=/headerrouting/**
    filters:
      - SetPath=/200

  - id: host_route_418
    uri: http://httpstat.us
    predicates:
      - Host=im.a.teapot:8080
      - Path=/headerrouting/**
    filters:
      - SetPath=/418

  - id: host_route_501
    uri: http://httpstat.us
    predicates:
      - Path=/headerrouting/**
    filters:
      - SetPath=/501

# spring.security.oauth2.resourceserver.jwt.issuer-uri ka kaam ye hota hai ke resource server
# (yani yahan gateway) ko batana “kis authorization server ne token issue kiya tha” —
# aur uska public key (JWK set - Json Web Keyset) kahan se milega taake woh JWT verify kar sake.
spring.security.oauth2.resourceserver.jwt.issuer-uri: http://${app.auth-server}:9999

management.endpoint.gateway.enabled: true
management.endpoint.health.show-details: "ALWAYS"
management.endpoints.web.exposure.include: "*"

logging:
  level:
    root: INFO
    org.springframework.cloud.gateway.route.RouteDefinitionRouteLocator: INFO
    org.springframework.cloud.gateway: TRACE


# In the docker-profile which is after --- we are overriding only few properties, the properties that are
# not overridden (defined again) will take the values from above (before ---). Springboot merges both these
# documents and apply profile based overrides.
# Values in a profile override values from the default profile. But other values comes as it is.
# By using YAML files, multiple Spring profiles can be placed in the same file, separated by ---

---

spring.config.activate.on-profile: docker

app:
  eureka-server: eureka
  auth-server: auth-server